npx create-react-app react-course
go to folder react-course

and run npm start

open index js
    delete import reportWebVitals from './reportWebVitals';
inedex.js

import React from 'react';
import ReactDOM from 'react-dom/client';

import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App/>);

app.js 

import { useDebugValue } from "react";

function App() {
  return <div> Hello ! </div>;
}

export default App;

* name of the component function stars with capital character like Todo();

* export default Todo;

* for adding your component in App.js 
    <Todo/> [end with self closing tag]


/* Geeky Shows 12.12.22 */

React.createElement(type, props, children)
React.render(element, DOMnode)

using react dom. render

ReactDom.render(<App/>, document.getElementById("root")); 

class App extends Component {
  render() {
    return <h1>Hi Max</h1>
  }
}
-> look up, this render() can return only one item.
-> you have to use div when 2 h1 tag you have.

# For returning multiple element

class App extends Component {
  render() {
    return (
      <React.Fragment>
        <h1>hi</h1>
        <h2>hi2</h2>
      </React.Fragment>
      or 
      <>
        <h1>hi</h1>
        <h2>hi2</h2>
      </>
    );
  }
}


# React fragment

* fragment is used for returning multiple element
-> normal fragment

return (
      <React.Fragment> or <div><div/>
        <h1>hi</h1>
        <h2>hi2</h2>
        <Student name="Rahul"/>
      </React.Fragment>
    );

-> fragment with key
 <React.Fragment key={id}>
        <h1>hi</h1>
        <h2>hi2</h2>
        <Student name="Rahul"/>
      </React.Fragment>
    );


short hand

<>
<h1>hi</h1>
        <h2>hi2</h2>
<Student name="Rahul"/>
</>


# component composing

A separate file that can use multiple time in your code. that is called as composing.

<Student/> [with self closig tag]
 

# Component & composing

import React, { Component } from "react";

# normal style

function Student() {
    return <h1>I am from student comp</h1>;
}

# es 6 style
const Student = props => {
    return <h1>hi {props.name}</h1>;
}

const Student = (props) => {
  return (
    <div>
      <h1>HI im {props.x}</h1>
      <h1>HI im es 6</h1>
      <h1>HI im es 6</h1>
    </div>
  );
};

// class based

class Student extends Component {
    render() {
        return <h1>Hello {this.props.name}</h1>
    }
}

export default Student;

# 12/29/22

# functional vs Class components

-> functional component is easy to use 
-> when you need state hook or life cirle hook use class based components

#  JSX in JS

-> JS is JS XML
-> it a preprocessor

-> JSX represents objects

-> atribute in JSX

const el = <h1 className="bg"> Hello </h1>

-> after conversion in babel

const el = React.createElement("h1", {
  className : "bg"
}, "Hello");

-> looks in props

const el = props {
  type : "h1", 
  props: {
  className : "bg",
  children : 'Hello'
  }
};


# props type cheking

-> install with npm and import in your file 

import PropTypes from 'prop-types';

-> cheking PropTypes

Student.propTypes = {
  name: PropTypes.string, 
  roll: PropTypes.number.isRequired
}

Student.defaultProps = {
  name: "Monk"
}

declare above export default

-> optional types

PropTypes.array
PropTypes.bool
PropTypes.func
PropTypes.number
PropTypes.object
PropTypes.string
PropTypes.symbol


# Children in JSX

-> before we are writing like self closing now we are writing open and end.

-> <Student> I am child </Student>
-> {100 + 3} or js expression

-> Accessing props
<h1> HI {props.children} </h1>

# 30/12/22

# State in React

-> state is make for only class based component

-> initializig state 
1. direcly inside class
2. inside the constructor


-> direcly inside ex:

  class Students extends Component {
  state = {
    name : "Rahul"
  }

  render() {
    return(
      <h1>Hello {this.state.name}</h1>
    );
  }
}

-> props is read only, but when you assign props in state you can modify it. we will see it letter..

ex.code : 

class Students extends Component {
  state = {
    name: "Rahul",
    roll: this.props.roll,
  };

  render() {
    return (
      <>
        <h1>Hello {this.state.name}</h1>
        <h3>Your roll is : {this.state.roll}</h3>
      </>
    );
  }
}

-> direcly constructor ex:

class Students extends Component {
  constructor(props) {
    super(props);
    this.state = {
      name: "Rahul",
      roll: this.props.roll,
    };
  }

  render() {
    return (
      <>
        <h1>Hello {this.state.name}</h1>
        <h3>Your roll is : {this.state.roll}</h3>
      </>
    );
  }
}

# Event handling

-> in react

<button onClick={handleClick}> Click me </button> // functional component

<button onClick={this.handleClick}> Click me </button> // class based component


-> example 
  class Student extends Component{

// arrow function can inherite this
  handleClick = () => {
    console.log("button click", this)
  }

  render(){
    return (
      <>
        <h1>hello sir</h1>
        <button onClick={this.handleClick}>click me</button>
      </>
    );
  }
}

-> if you use regular function 

class Student extends Component {
  constructor(props) {
    super(props);
    
    this.state = {
      name : "rahul",
      roll : this.props.roll
    }
  // you have to bind this
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    console.log("button click", this);
  }

  render() {
    return (
      <>
        <h1>hello {this.state.name}</h1>
        <h1>your roll is  :  {this.state.roll}</h1>
        <button onClick={this.handleClick}>click me</button>
      </>
    );
  }
}

# in functional component

function Student(props) {

  function handleClick() {
    document.body.style.color = "red";
  }

  return(
    <>
      <h1>Hello {props.name}</h1>
      <h1>your roll is :  {props.roll}</h1>
      <button onClick={handleClick}>click here</button>
    </>
  );
}

# how to stop current behabior

 function handleClick(e) {
    e.preventDefault();
    console.log("button click");
}

-> it will stop his current behav like in achor tag, link does not work.

date : 31/12/22

#  setState()
->
ex: 
class Student extends Component{
  constructor(props) {
    super(props);

    this.state = {
      name: "rahul",
      roll: this.props.roll
    };

  }
// using setState() for updating state
  handleclick = () => {
    this.setState({name : "Jai", roll : "292"});
  }

  render() {
    return(
      <>
        <h1>Hello Gekkey shows</h1>
        <h1>Hello, {this.state.name}</h1>
        <h1>Hello, {this.state.roll}</h1>

        <button onClick={this.handleclick}>click me</button>
      </>
    )
  }
}

# update state

class Student extends Component{
  constructor(props) {
    super(props);

    this.state = {
      name: "rahul",
      roll: this.props.roll
    };

  }

  handleclick = () => {
    this.setState(function(state, props){
      console.log(state, props);
    })
  }

  render() {
    return(
      <>
        <h1>Hello Gekkey shows</h1>
        <h1>Hello, {this.state.name}</h1>
        <h1>Hello, {this.state.roll}</h1>

        <button onClick={this.handleclick}>click me</button>
      </>
    )
  }
}


export default Student;


# passign argument to event handler

 ex-1

  class Student extends Component {
  // state without constructor

  state = {
    id : 2,
    name : "rahul"
  }
// event handler
  handleClick = (id,e) => {
    console.log(id,e);
  };
// this is a helper function for passing perameter, this return a handler
  handleCLickArg = (e) => {
    this.handleClick(this.state.id,e)
  }

  render() {
    return (
      <>
        <h1>Hello Gekkey shows</h1>
        <h1>Hello, {this.state.name}</h1>
        <h1>Hello, {this.state.roll}</h1>

        <button onClick={this.handleCLickArg}>click me</button>
      </>
    );
  }
}

-> short hand version


version - 1

  <button onClick={e => {
    this.handleClick(this.state.id,e)
  }}> button </button>

version - 2

  <button onClick={this.handleClick.bind(this, this.state.id)}>button</button>

# Phase of component

1. mounting 2. updating 3. error handling
4. unmounting

1. all components hold in memory
2. react also maintain a virtual dom along side
3. virtual dom to webpage rendering, in middle place is called mounting

4. if we change anything in virtual dom that is called mounting
5. if you have any error then error handling

# life cycle methode

1. mounting 2. updating 3. error handling
4. unmounting

constructor() is used for binding this, or create state inside class.

1. mounting -> 

constructor()
in constructor you must call super(props)
that will call parent props in your derived class. it is important. 

* initializig local state by assiging an object to this. 
ex:- this. State = {name: "rahul"}

* binding even handler methods to an instance

constructor(props) {
  super(props);
  this.state = {
    name : "rahul",
    roll : this.props.roll
  };

  this.handleClick = this.handClick.bind(this);
}

static getDerivedStateFromProps()
render()
component()

how to execute first 
1. constructor()
2. getDerivedStateFromProps()
3. render()
4. componetDidMount()

in class component

static getDerivedStateFromProps(props, state){
    console.log("App - get derived state from props");
    console.log(props, state);
    return null;
  }


1/1/23

# getDerivedStateFromProps(props, state)
 
 Example : need 2 file 1 student, 2 mark

 for stuent file:

 import React, { Component } from 'react'
import Mark from "./mark"

export default class Student extends Component {
  // component
  constructor() {
    super();
    this.state = {
      roll : 101,
      name : "koushik"
    }
  }
  
  clickHandle = () => {
    console.log("button clicked");
    this.setState({roll: this.state.roll + 2});
  }

  render() {
    return (
      <div>
        <Mark roll = {this.state.roll}/>
        <button onClick={this.clickHandle}>change</button>
      </div>
    )
  }
}

-> for mark file 

  import React, { Component } from 'react'

export default class mark extends Component {

  constructor(props) {
    super(props);
    this.state = {
      mroll: this.props.roll
    }
  }

  static getDerivedStateFromProps(props, state){
    console.log("Get derived state from props");
    if(props.roll !== state.mroll) {
      return {mroll : props.roll};
    }
    return null;
  }


  render() {
    return (
      <>
        <h1>{this.state.mroll}</h1>
      </>
    );
  }
}

# shouldComponentUpdate(nextProps, nextState)

shouldComponentUpdate(nextProps, nextState) {
    if (this.state.mroll < 107) {
      console.log("Mark - ShouldComponentUpdate");
      console.log(nextProps, nextState);
      return true;
    }
    console.log(nextProps, nextState);
    return false;
  }

# getSnapshotBeforeUpdate(prevProps, prevState, snapshot){
  return 45;
}

# componentDidUpdate(prevProps, prevState, snapshot){
  console.log(prevProps, prevState, snapshot)
  // previous funtion return value will come in snapshot.
}

# componentDidMount()
# componentWillUnmount()

# for unmounting
  ReactDOM.unmountComponentAtNode(document.getElementById("root"));


2/1/23

# Rules of HOOKS

* only call hooks at top level, we  should not call hooks inside loops.
* only call in Hooks from Ract function component
* React relies on the order in which hooks are called.
* Hooks don't work inside classes

# useState() Hooks

* fist import {useState}
* it retrurns a array with 2 value, first value, second function


ex : 

import React, {useState} from 'react';

export default function App() {
  // hooks
  // const nameStateVariable = useState(1);
  const [name, setName] = useState("Rahul");
  const [roll, setRoll] = useState(101);

  // handler
  const fire = () => {
    setName("Geek");
    setRoll(103);
  }

  return <>
    <h1>hi {name}</h1>
    <h1>hi {roll}</h1>
    <button type='button' onClick={fire}>click</button>
  </>
}

# useEffect Hook

componentDidMount()
componentDidUpdate()
componentWillUnmount()  

these 3 combination is useEffect hook.

By using this hook, you tell React that your componet needs to do something after render.

* useEffect(()=>{
  // it called when component mount and update
})

ex:

import React, {useState, useEffect} from 'react'

export default function App() {

  const [count, setCount] = useState(0);
  const [count1, setCount1] = useState(50);

  const fire = () => {
    setCount(count + 1);
  };

  const fire1 = () => {
    setCount1(count1 - 1);
  };

  useEffect(()=>{
    console.log("Use Effect Called");
  }, [count]) // count is here depenedent value, useEffect works for only if count is update.

  return (
    <>
    <h1>Count up: {count}</h1>
    <button type='button' onClick={fire}>click here</button>
    <h1>Count down: {count1}</h1>
    <button type='button' onClick={fire1}>click here</button>
    </>
  );

}

# Custom hook

syntaxt : function useCustomCounter() // use keyword before function name

import React, {useState} from 'react'

export default function useCustomCounter() {
    const [count, setCount] = useState(0);

    const handleIncreament = ()=> {
        setCount(count + 1);
    };

    return {
        count,
        handleIncreament
    }
}

 
# Conditional rendering

* you can not put condition inside JSX
* you can put condition inside render() methode

ex: 

export default class App extends Component {

  constructor(props) {
    super(props);
    this.state = {
      consumer : true
    }
  }

render() {
    // logic
    const isReistered = this.state.consumer;

    if(isReistered){
      return <User/>
    }
    return <Guest/>

  }

  # inline if with logical && operator

  true && expression = expression

  ex : purchess && <Payment/> [if purchess evaluates true, the payment will be return]

  flase && expression = false

  ex : purchess && <Payment/> [if purchess evaluates false, the payment will be ignored]

  true && expression && expression2 = expression2 [most right hand side]

  you can use ternary expression like

  condition ? expression : expression
  true ? this will run if true : this will run if false

  iife = imediate invoked funciton expression

  syntax :
    return (
      <div>
          (()=>{
            // your code.
          })()
      <div/>
    )

# constrolling 2 state with conditon example 

  ex:

  -> App file
import React, { Component } from 'react'
import User from './User'
import Guest from './Guest'

export default class App extends Component {

  state = {
    isLoggedIn : false
  }

  clickLogin = () => {
    this.setState({isLoggedIn: true});
  }
  clickLogOut  = () => {
    this.setState({isLoggedIn: false});
  }

  render() {
    const isLoggedIn = this.state.isLoggedIn;

      return (
        isLoggedIn ? <User clickData = {this.clickLogOut}/> : <Guest clickData={this.clickLogin}/>
      )
      
  }
}

-> guest file
  import React, { Component } from 'react'

export default class Guest extends Component {
  render() {
    return (
      <div>
        <h1>Wellcome Guest</h1>
        <button onClick={this.props.clickData}>Login</button>
      </div>
    )
  }
}

-> user file

import React, { Component } from 'react'

export default class User extends Component {
  render() {
    return(
        <>
        <h1>Wellcome Rahul</h1>
        <button onClick={this.props.clickData}>Logout</button>
        </>
    );
  }
}

4/1/23

#list in react

export default class App extends Component {
render(){
    // logic area
    const arr  = [10, 20, 30, 40];
    const newArr = arr.map((num)=>{
      console.log("Num = ", num);
      return <li>{num * 2}</li>
    });

    console.log("old arr = ",arr);
    // return area
    return(
      <ul>
        <li>{newArr}</li>
      </ul>
    );
  }
}

anoter syntax

export default class App extends Component {
  render(){
    // logic area
    const arr  = [10, 20, 30, 40];
    // return area
    return(
      <ul>
        {
          arr.map(num => <li>{num}</li>)
          
          or

          arr.map((num)=>{
            return <li>{num}</li>
          })

        }
      </ul>
    );
    
  }
}


You can assing array as a props
ex: const arr  = this.props.number;

state :

import React, { Component } from 'react'

export default class App extends Component {
// state
state = {
  users: [
    {id: 101, name:"rahul", pass: "2324sdf"},
    {id: 121, name:"moka", pass: "23sdsdf"},
    {id: 102, name:"anik", pass: "23dfsdf"}
  ],
  isLoggedIn: false
}
  // handler

  render(){
    // logic area
    const arr  = this.props.number;
    // return area
    return(
      <>
      <h1>{this.state.users[0].id}</h1>
      </>
    );
    
  }
}

# with state object

import React, { Component } from 'react'

export default class App extends Component {
// state
state = {
  users: [
    {id: 101, name:"rahul", pass: "2324sdf"},
    {id: 121, name:"moka", pass: "23sdsdf"},
    {id: 102, name:"anik", pass: "23dfsdf"}
  ],
  isLoggedIn: false
}
  // handler

  render(){
    // logic area
    const mapUserArr = this.state.users.map((user)=>{
      console.log(user);
      return(<h1>
        id: {user.id} Name : {user.name} password: {user.pass}
      </h1>);
    });
    // return area
    return(
      <>
      <ul>
        <li>{mapUserArr}</li>
      </ul>
      </>
    );
  }
}

# key in list
 * you can not pass key as an atribute or props mind it.
 * dont try to make array index as a key
 * a good rule of thumb is that element inside all map() call need keys.
 * give key them that you want to catch add, remove , update


 ex: 
-> user file:
import React, { Component } from 'react'

export default class User extends Component {
  render() {
    return (
      <li>{this.props.value}</li>
    )
  }
}

-> index file
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

const arrValues = [19, 29, 28, 82];

ReactDOM.render(<App numbers={arrValues}/>, document.getElementById("root"));

-> app.js

import React, { Component } from "react";
import User from "./User";

export default class App extends Component {
  render() {
    // logic area
    const arr = this.props.numbers;
    const newArr = arr.map((e) => {
      return <User key={e} value={e} />;
    });
    return (
      <div>
        <ul>{newArr}</ul>
      </div>
    );
  }
}

# react with css

-> inline Stylesheet
-> external Stylesheet
-> css module
-> css in javascript   

* classes are generally better performed than inline css

inline example

export default class App extends Component {
  state = {
    change : false
  }
  // handler
  clickHandle = () => {
    this.setState({change : true})
    console.log(12)
  }
  render() {
    const btnStyle = {
      color : 'black',
      backgroundColor: 'orange'
    }

    if(this.state.change){
      btnStyle.backgroundColor = 'white'
    }

    // return area
    return (
      <>
      <button onClick={this.clickHandle} style={btnStyle}>Button</button>

      </>
    )
  }
}

external example :
* you have to import css file like
import 'App.css' [dont forgot to put .css extention]

* you can use external css for global use only6fsff

-> for app.css
import React, { Component } from 'react'
import './App.css'
import User from './User'

export default class App extends Component {
  render() {
    //css
    let style = false;

    return (
      <>
      <User color={style ? "txtb" : "txtg"}/></>
    )
  }
}

-> For user.js

import React, { Component } from 'react'
import './User.css'

export default class User extends Component {
  render() {
    return (
     <>
      <p className={this.props.color}>this is bangaleshm, this is an amezing country</p>
     </>
    )
  }
}


5/1/23

# css module 

* you have to make file with .module.css extention
like App.module.css 
* module can remove css conflick like external css that we saw before
* import idea ex:
import Styles from "./App.module.css"

* if you go webpage and inspect then you will see it generate App_clas_name_hash . that is why it is unique.

* Accessing -> 

className={Styles.css}

# image and assets in react js

 * you can put your image in public folder or src folder
 * if you put it public folder webpack won't touch it.
it wont be processed by webpack

* some public folder Rules

1. none of the files in public folder get post-porcessed or minified
2. missing file will not called at compilation time


when use public folder

* you neeed a file with specific name in the build output such as minifest, webmanifest
* you have thousands of images and need to dynamically reference their path

how to access img in public folder

* its for direct index.html file
<img src="%PUBLIC_URL%/pic_2.jpg" width="200px" alt="">
* you have to use %PUBLIC_URL% preprocessor

* it's for separate file
like other return component
<img src= {process.env.PUBLIC_URL + "/pic_2.jpg"}
    width="300px"/>


-> now import for locally with import methode
import pic from './img/pic.png'
 <img src= {pic} width="30%"/>

# how to use bootstrap in React

* you can install it as a package like
npm install bootstrap
or specific version npm install bootstrap@4.2.1
you you can check npm js website


# form in RJ

* uncontroled component
index.html file

 <form>
      <div class="form-group">
        <h2>uncontroled by react</h2>
        <label for="exampleInputEmail1">Email address</label>
        <input class="form-control"type="text" value="u geek" />
      </div>
    </form>


* constroled component

<form>
    <div class="form-group">
            <h2>controlled by react</h2>
            <label for="exampleInputEmail1">Email address</label>
            <input className="form-control" type="text" value="Geek" />
          </div>
        </form>

* you can not remove it. because of it is a prop, means value atribute became porp here.
* if you change value attribute to defaultValue then you can edit it.


* you can remove given value.
 
-> how to handle user data using onChange event handler

export default class App extends Component {
  // state
  state = {
    value : ""
  }

  // handler function
  handleChange = (e) => {
    console.log(e.target.value);
    this.setState({value: e.target.value.toUpperCase().substr(0, 10)})
  }
  render() {
    return (
      <>
        <form>
            <h2>controlled by react</h2>
            <label for="exampleInputEmail1">Email address</label> <br/>
            <input type="text" value={this.state.value} onChange={this.handleChange}/>
        </form>
      </>
    );
  }
}


8/1/23

# how to handle form in react

onSubmit={this.handleClick} is a from atribute

handleClick = () => {
  e.target or e.targer.[0]
}

ex:

import React, { Component } from "react";


export default class App extends Component {
  // state 
  state = {
    name : "unknown",
    password : "pass"
  };

  // handle pass
  handleChange =(e)=>{
    this.setState({[e.target.name] : e.target.value})
  };

  handleSubmit = (e) => {
    console.log(e.target[1].name);
    e.preventDefault();

  } 

  render() {
    return (
      <>
        <h4 style={{ textAlign: "center", color: "red" }}>this is a form</h4>
        <form onSubmit={this.handleSubmit}>
          <label> name : <input type="text" value={this.state.name} onChange={this.handleChange} name="name"/> </label> <br/>

          <label> password : <input type="text" value={this.state.password} onChange={this.handleChange} name="password"/> </label> <br/>
          {/* buttons */}

          <button type="submit" value='submit' >submit</button>
        </form>
      
      </>
    );
  }
}

# uncontrolled component

* you can use a refs to get form values form dom

-> when to use refs
* managing focus text selection or media playback
* trigerrign imperative animations
* integratig with third party dom libraries

-> creating reference
this.<name> = React.createRef();
this.textArea = React.createRef();

Example : 

import React, { Component } from 'react'

export default class App extends Component {
  constructor(props) {
    super(props);

    // createing ref
    this.ref = React.createRef();
  }

  componentDidMount = () =>{
    console.log(this.ref);
    this.ref.current.focus();
  }

  render() {
    return (
      <div>

        <form>
          name : <input type="text" ref={this.ref}/> <br/>
          password : <input type="password" /> <br/>
          address : <input type="text"/> <br/>
        </form>

      </div>
    )
  }
}

Example 2:

import React, { Component } from 'react'

export default class App extends Component {
  constructor(props) {
    super(props);

    this.state = {
      value : ""
    }
    // createing ref
    this.ref = React.createRef();
  }

  handleSubmit = (e) => {
    e.preventDefault();
    this.setState({value : this.ref.current.value});
  }

  render() { 
    return (
      <div>
        <h2>you typed : {this.state.value}</h2>
        <form onSubmit={this.handleSubmit}>
          name : <input type="text" ref={this.ref} /> <br/>
          password : <input type="password" /> <br/>
          address : <input type="text"/> <br/>
          <input type="submit" value='submit'/>
        </form>

      </div>
    )
  }
}

# Callback ref

-> Creating Callback ref
constructor() {
  super();
  this.backRef = null;
  this.setBackRef = e => {
    this.backRef = e;
  }
}

Example : 
import React, { Component } from 'react'

export default class App extends Component {
  constructor(props) {
    super(props);
    this.backRef = null;

    this.setBackRef = element => {
      this.backRef = element;
    }
  }

  componentDidMount = () => {
    if(this.backRef) {
      this.backRef.focus();
    }
  };

  render() {
    return (
      <div>
        <form>
          name : <input type="text" ref={this.setBackRef} /> <br/>
          password : <input type="password" /> <br/>
          address : <input type="text"/> <br/>
          <input type="submit" value='submit'/>
        </form>

      </div>
    )
  }
}

# Lifting State Up


# contexApi in react

1. export your context object
export const myContex = React.createContext();

2. you need state
state = {
    name: "KoushiK Ahmed",
  };

3. context provider
* it needs value artribute with states
<myContex.Provider value={this.state.name}>
          <User />
        </myContex.Provider>

4.import context
import { myContex } from "./App";

4. context consumer
 <myContex.Provider value={this.state.name}>
          <User />
  </myContex.Provider>


-> Full example : 

-> app.js file

import React, { Component } from "react";
import User from "./User";
export const myContex = React.createContext();

export default class App extends Component {
  state = {
    name: "KoushiK Ahmed",
  };
  render() {
    return (
      <div>
        <myContex.Provider value={this.state.name}>
          <User />
        </myContex.Provider>
      </div>
    );
  }
}

-> User.js file

import React, { Component } from "react";
import { myContex } from "./App";

export default class User extends Component {
  render() {
    return (
      <div>
        <h1>user component</h1>
        <myContex.Consumer>{(data) => <h4>{data}</h4>}</myContex.Consumer>
      </div>
    );
  }
}

-> you can use context as seperate file

step 1. make a separate file and 

import React from 'react'
const MyContext = React.createContext();
export const Provider = MyContext.Provider;
export const Consumer = MyContext.Consumer;

Step 2. import provider
import { Provider } from "./Context";

Step 3. import consumer
import { Consumer } from "./Context";

Step 4. write your return function
<Consumer>
          {(data) => {
            <h1>{data}</h1>
          }}
        </Consumer>


# constext type

S-1:
Separate context file - 
export const MyContext = React.createContext();
export const Provider = MyContext.Provider;

S-2:
for Consumer class
inside class

import {MyContext} from "./Context"
static contextType = MyContext;

S-3:
you dont need to consumer block
rather than use 

this.context.data.name 

S-4:

you can use it component life cycle previously not.

# Higher order componet

